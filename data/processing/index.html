<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <!-- Syntax highlighting via Prism, note: restricted langs -->
<link rel="stylesheet" href="/DataScienceTutorials.jl/libs/highlight/github.min.css">
 
  <link rel="stylesheet" href="/DataScienceTutorials.jl/css/franklin.css">
  <link rel="stylesheet" href="/DataScienceTutorials.jl/css/pure.css">
  <link rel="stylesheet" href="/DataScienceTutorials.jl/css/side-menu.css">
  <link rel="stylesheet" href="/DataScienceTutorials.jl/css/extra.css">
  <!-- <link rel="icon" href="/DataScienceTutorials.jl/assets/infra/favicon.gif"> -->
   <title>Further data processing</title>  
  <!-- LUNR -->
  <script src="/DataScienceTutorials.jl/libs/lunr/lunr.min.js"></script>
  <script src="/DataScienceTutorials.jl/libs/lunr/lunr_index.js"></script>
  <script src="/DataScienceTutorials.jl/libs/lunr/lunrclient.min.js"></script>
</head>
<body>
  <div id="layout">
    <!-- Menu toggle / hamburger icon -->
    <a href="#menu" id="menuLink" class="menu-link"><span></span></a>
    <div id="menu">
      <div class="pure-menu">
        <a href="/DataScienceTutorials.jl/" id="menu-logo-link">
          <div class="menu-logo">
            <!-- <img id="menu-logo" alt="MLJ Logo" src="/DataScienceTutorials.jl/assets/infra/MLJLogo2.svg" /> -->
            <p><strong>Data Science Tutorials</strong></p>
          </div>
        </a>
        <form id="lunrSearchForm" name="lunrSearchForm">
          <input class="search-input" name="q" placeholder="Enter search term" type="text">
          <input type="submit" value="Search" formaction="/DataScienceTutorials.jl/search/index.html" style="visibility:hidden">
        </form>
  <!-- LIST OF MENU ITEMS -->
  <ul class="pure-menu-list">
    <li class="pure-menu-item pure-menu-top-item "><a href="/DataScienceTutorials.jl/" class="pure-menu-link"><strong>Home</strong></a></li>

    <!-- DATA BASICS -->
    <li class="pure-menu-sublist-title"><strong>Data basics</strong></li>
    <ul class="pure-menu-sublist">
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/data/loading/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Loading data</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/data/dataframe/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Data Frames</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/data/categorical/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Categorical Arrays</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/data/scitype/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Scientific Type</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/data/processing/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Data processing</a></li>
    </ul>

    <!-- GETTING STARTED WITH MLJ -->
    <li class="pure-menu-sublist-title"><strong>Getting started</strong></li>
    <ul class="pure-menu-sublist">
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/choosing-a-model/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Choosing a model</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/fit-and-predict/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Fit, predict, transform</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/model-tuning/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Model tuning</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/ensembles/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Ensembles</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/ensembles-2/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Ensembles (2)</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/ensembles-3/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Ensembles (3)</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/composing-models/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Composing models</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/learning-networks/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Learning networks</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/learning-networks-2/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Learning networks (2)</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/getting-started/stacking/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Stacking</a></li>
    </ul>

    <!-- INTRO TO STATS LEARNING -->
    <li class="pure-menu-sublist-title"><strong>Intro to Stats Learning</strong></li>
    <ul class="pure-menu-sublist" id=isl>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-2/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 2</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-3/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 3</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-4/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 4</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-5/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 5</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-6b/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 6b</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-8/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 8</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-9/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 9</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/isl/lab-10/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Lab 10</a></li>
    </ul>

    <!-- END TO END EXAMPLES -->
    <li class="pure-menu-sublist-title"><strong>End to end examples</strong></li>
    <ul class="pure-menu-sublist" id=e2e>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/AMES/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> AMES</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/wine/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Wine</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/crabs-xgb/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Crabs (XGB)</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/horse/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Horse</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/HouseKingCounty/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> King County Houses</a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/airfoil" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Airfoil </a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/boston-lgbm" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Boston (lgbm) </a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/glm/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Using GLM.jl </a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/powergen/" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Power Generation </a></li>
      <li class="pure-menu-item "><a href="/DataScienceTutorials.jl/end-to-end/boston-flux" class="pure-menu-link"><span style="padding-right:0.5rem;">•</span> Boston (Flux) </a></li>
    </ul>
  </ul>
  <!-- END OF LIST OF MENU ITEMS -->
      </div>
    </div>
    <div id="main"> <!-- Closed in foot -->
      

<!-- Content appended here -->
<div class="franklin-content"><h1 id="further_data_processing"><a href="#further_data_processing">Further data processing</a></h1>
<em>Download the</em> <a href="https://raw.githubusercontent.com/alan-turing-institute/DataScienceTutorials.jl/gh-pages/generated/notebooks/D0-processing.ipynb" target="_blank"><em>notebook</em></a>, <em>the</em> <a href="https://raw.githubusercontent.com/alan-turing-institute/DataScienceTutorials.jl/gh-pages/generated/scripts/D0-processing-raw.jl" target="_blank"><em>raw script</em></a>, <em>or the</em> <a href="https://raw.githubusercontent.com/alan-turing-institute/DataScienceTutorials.jl/gh-pages/generated/scripts/D0-processing.jl" target="_blank"><em>annotated script</em></a> <em>for this tutorial &#40;right-click on the link and save&#41;.</em> <div class="franklin-toc"><ol><li><a href="#more_data_processing">More data processing</a></li></ol></div><h2 id="more_data_processing"><a href="#more_data_processing">More data processing</a></h2>
<p>This tutorial uses the World Resources Institute Global Power Plants Dataset to explore data pre-processing in Julia. The dataset is created from multiple sources and is under continuous update, which means that there are lots of missing data, non-standard characters, etc Hence plenty of material to work with&#33;</p>
<p>More tutorials on the manipulation of DataFrames can be found <a href="https://github.com/bkamins/Julia-DataFrames-Tutorial">here</a> And some more information can be found on <a href="https://en.wikibooks.org/wiki/Introducing_Julia/DataFrames">this</a> wikipage.</p>
<pre><code class="language-julia">import MLJ: schema, std, mean, median, coerce, coerce!, scitype
using DataFrames
using UrlDownload
using PyPlot</code></pre>
<p>Import data</p>
<pre><code class="language-julia">raw_data = urldownload("https://github.com/tlienart/DataScienceTutorialsData.jl/blob/master/data/wri_global_power_plant_db_be_022020.csv?raw=true")
data = DataFrame(raw_data);</code></pre>
<p>This dataset contains information on power generation plants for a number of countries around the world. The level of disaggregation is the power plant. For each plant, there is information about its name, localisation, capacity, and many other features. The schema function enables us to get a quick overview of the variables it contains, including their machine and scentific types.</p>
<pre><code class="language-julia">schema(data)</code></pre><pre><code class="plaintext">┌──────────────────────────┬─────────────────────────┬────────────────────────────┐
│ _.names                  │ _.types                 │ _.scitypes                 │
├──────────────────────────┼─────────────────────────┼────────────────────────────┤
│ country                  │ String                  │ Textual                    │
│ country_long             │ String                  │ Textual                    │
│ name                     │ String                  │ Textual                    │
│ gppd_idnr                │ String                  │ Textual                    │
│ capacity_mw              │ Float64                 │ Continuous                 │
│ latitude                 │ Float64                 │ Continuous                 │
│ longitude                │ Float64                 │ Continuous                 │
│ primary_fuel             │ String                  │ Textual                    │
│ other_fuel1              │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ other_fuel2              │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ other_fuel3              │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ commissioning_year       │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ owner                    │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ source                   │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ url                      │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ geolocation_source       │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ wepp_id                  │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ year_of_capacity_data    │ Union{Missing, Int64}   │ Union{Missing, Count}      │
│ generation_gwh_2013      │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ generation_gwh_2014      │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ generation_gwh_2015      │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ generation_gwh_2016      │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ generation_gwh_2017      │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ generation_data_source   │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ estimated_generation_gwh │ Union{Missing, Float64} │ Union{Missing, Continuous} │
└──────────────────────────┴─────────────────────────┴────────────────────────────┘
_.nrows = 33643
</code></pre>
<p>We see that a small number of features have values for all plants &#40;i.e. for each row&#41; present in the dataset. However, &#40;i&#41; several features have missing values &#40;Union&#123;Missing, _.type&#125;&#41; and &#40;ii&#41; we are not interested in working with all of these features. In particular, we&#39;re not intersted in the source of the information present in the dataset nor are we interested in the generation data. Hence we drop all columns which contain information&#39;s source. We define a function <code>is_active&#40;&#41;</code> that will return a <code>TRUE</code> boolean value if the column name does NOT &#40;<code>&#33;</code>&#41; contain either of the strings &quot;source&quot; or &quot;generation&quot;. Note the conversion of column names from <code>:Symbol</code> to <code>:string</code> since the <code>occursing</code> function only accepts strings as arguments.</p>
<pre><code class="language-julia">is_active(col) = !occursin(r"source|generation", string(col))
active_cols = [col for col in names(data) if is_active(col)]
select!(data, active_cols);</code></pre>
<p>We also drop a number of other unwanted columns and take a look at our &quot;new&quot; dataframe.</p>
<pre><code class="language-julia">select!(data, Not([:wepp_id, :url, :owner]))
schema(data)</code></pre><pre><code class="plaintext">┌───────────────────────┬─────────────────────────┬────────────────────────────┐
│ _.names               │ _.types                 │ _.scitypes                 │
├───────────────────────┼─────────────────────────┼────────────────────────────┤
│ country               │ String                  │ Textual                    │
│ country_long          │ String                  │ Textual                    │
│ name                  │ String                  │ Textual                    │
│ gppd_idnr             │ String                  │ Textual                    │
│ capacity_mw           │ Float64                 │ Continuous                 │
│ latitude              │ Float64                 │ Continuous                 │
│ longitude             │ Float64                 │ Continuous                 │
│ primary_fuel          │ String                  │ Textual                    │
│ other_fuel1           │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ other_fuel2           │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ other_fuel3           │ Union{Missing, String}  │ Union{Missing, Textual}    │
│ commissioning_year    │ Union{Missing, Float64} │ Union{Missing, Continuous} │
│ year_of_capacity_data │ Union{Missing, Int64}   │ Union{Missing, Count}      │
└───────────────────────┴─────────────────────────┴────────────────────────────┘
_.nrows = 33643
</code></pre>
<p>The remaining variables have two different scientific types: Continuous, Textual Of which we can get an overview.</p>
<pre><code class="language-julia">describe(data)

# The describe() function shows that there are several features with missing values.</code></pre><pre><code class="plaintext">13×8 DataFrame
│ Row │ variable              │ mean    │ min         │ median  │ max               │ nunique │ nmissing │ eltype                  │
│     │ Symbol                │ Union…  │ Any         │ Union…  │ Any               │ Union…  │ Union…   │ Type                    │
├─────┼───────────────────────┼─────────┼─────────────┼─────────┼───────────────────┼─────────┼──────────┼─────────────────────────┤
│ 1   │ country               │         │ AFG         │         │ ZWE               │ 167     │          │ String                  │
│ 2   │ country_long          │         │ Afghanistan │         │ Zimbabwe          │ 167     │          │ String                  │
│ 3   │ name                  │         │ 'Muela      │         │ \u200bVärtaverket │ 33232   │          │ String                  │
│ 4   │ gppd_idnr             │         │ ARG0000001  │         │ WRI1075863        │ 33643   │          │ String                  │
│ 5   │ capacity_mw           │ 168.993 │ 1.0         │ 18.3    │ 22500.0           │         │          │ Float64                 │
│ 6   │ latitude              │ 32.5014 │ -77.847     │ 39.5835 │ 71.292            │         │          │ Float64                 │
│ 7   │ longitude             │ -4.1955 │ -179.978    │ -1.2744 │ 179.389           │         │          │ Float64                 │
│ 8   │ primary_fuel          │         │ Biomass     │         │ Wind              │ 15      │          │ String                  │
│ 9   │ other_fuel1           │         │ Biomass     │         │ Wind              │ 12      │ 31680    │ Union{Missing, String}  │
│ 10  │ other_fuel2           │         │ Biomass     │         │ Wind              │ 11      │ 33340    │ Union{Missing, String}  │
│ 11  │ other_fuel3           │         │ Biomass     │         │ Wind              │ 7       │ 33539    │ Union{Missing, String}  │
│ 12  │ commissioning_year    │ 1995.49 │ 1896.0      │ 2005.0  │ 2018.0            │         │ 17340    │ Union{Missing, Float64} │
│ 13  │ year_of_capacity_data │ 2016.86 │ 2000        │ 2017.0  │ 2018              │         │ 19900    │ Union{Missing, Int64}   │</code></pre>
<p><em>Note:</em> the <code>describe&#40;&#41;</code> function is from the &#91;Julia Base&#93; whereas the <code>schema&#40;&#41;</code> is from the MLJ package.</p>
<hr /> Let&#39;s play around with capacity data, for which there are no missing values. We create a sub-dataframe and aggregate over certain dimensions &#40;country and primary_fuel&#41;</p>
<pre><code class="language-julia">capacity = select(data, [:country, :primary_fuel, :capacity_mw]);
first(capacity, 5)</code></pre><pre><code class="plaintext">5×3 DataFrame
│ Row │ country │ primary_fuel │ capacity_mw │
│     │ String  │ String       │ Float64     │
├─────┼─────────┼──────────────┼─────────────┤
│ 1   │ AFG     │ Hydro        │ 33.0        │
│ 2   │ AFG     │ Solar        │ 10.0        │
│ 3   │ AFG     │ Solar        │ 10.0        │
│ 4   │ AFG     │ Hydro        │ 66.0        │
│ 5   │ AFG     │ Hydro        │ 100.0       │</code></pre>
<p>This dataframe contains several subgroups &#40;country and technology type&#41; and it would be interesting to get data aggregates by subgroup. To obtain a <code>view</code> of the DataFrame by subgroup, we can use the <code>groupby</code> function. &#40;See the <a href="https://alan-turing-institute.github.io/DataScienceTutorials.jl/data/dataframe/#groupby">DataFrame tutorial</a> for an introduction to the use of <code>groupby</code>&#41;</p>
<pre><code class="language-julia">cap_gr = groupby(capacity, [:country, :primary_fuel]);</code></pre>
<p>If we want to aggregate at the country-fuel-type level and calculate summary statistics at this level, we can use the <code>combine</code> function on the GroupedDataFrame that we just created. This function takes the GroupedDataFrame, the symbol of the column on which to apply the measure of choice as arguments.</p>
<pre><code class="language-julia">cap_mean = combine(cap_gr, :capacity_mw => mean)
cap_sum = combine(cap_gr, :capacity_mw => sum)
first(cap_sum, 3)</code></pre><pre><code class="plaintext">3×3 DataFrame
│ Row │ country │ primary_fuel │ capacity_mw_sum │
│     │ String  │ String       │ Float64         │
├─────┼─────────┼──────────────┼─────────────────┤
│ 1   │ AFG     │ Hydro        │ 238.55          │
│ 2   │ AFG     │ Solar        │ 20.0            │
│ 3   │ AFG     │ Gas          │ 42.0            │</code></pre>
<p>Now let&#39;s plot some of this aggregate data for a selection of countries, by country and technology type</p>
<pre><code class="language-julia">ctry_selec = r"BEL|FRA|DEU"
tech_selec = r"Solar"

cap_sum_plot = cap_sum[occursin.(ctry_selec, cap_sum.country) .& occursin.(tech_selec, cap_sum.primary_fuel), :]</code></pre><pre><code class="plaintext">3×3 DataFrame
│ Row │ country │ primary_fuel │ capacity_mw_sum │
│     │ String  │ String       │ Float64         │
├─────┼─────────┼──────────────┼─────────────────┤
│ 1   │ BEL     │ Solar        │ 116.2           │
│ 2   │ FRA     │ Solar        │ 4910.42         │
│ 3   │ DEU     │ Solar        │ 6770.56         │</code></pre>
<p>Note the <code>.</code> for element-wise comparison Before plotting, we can also sort values by decreasing order using <code>sort&#33;&#40;&#41;</code>.</p>
<pre><code class="language-julia">sort!(cap_sum_plot, :capacity_mw_sum, rev=true)

figure(figsize=(8,6))

plt.bar(cap_sum_plot.country, cap_sum_plot.capacity_mw_sum, width=0.35)
plt.xticks(rotation=90)</code></pre>
<img src="/DataScienceTutorials.jl/assets/data/processing/code/output/D0-processing-g1.svg" alt="the alt here">
<hr /> Now that we have the total capacity by country and technology type, let&#39;s use it to calculate the share of each technology in total capacity. To that end we first create a dataframe containing the country-level total capacity, using the same steps as above.</p>
<pre><code class="language-julia">cap_sum_ctry_gd = groupby(capacity, [:country]);
cap_sum_ctry = combine(cap_sum_ctry_gd, :capacity_mw => sum);</code></pre>
<p>The we join this dataframe with the disaggregated one; which requires that we convert the two GroupedDataFrame into DataFrames.</p>
<pre><code class="language-julia">cap_sum = DataFrame(cap_sum);
cap_sum_ctry = DataFrame(cap_sum_ctry);
cap_share = leftjoin(cap_sum, cap_sum_ctry, on = :country, makeunique = true)
cap_share.capacity_mw_share = cap_share.capacity_mw_sum ./ cap_share.capacity_mw_sum_1;</code></pre>
<p>Let&#39;s visualise our dataframe again, which now includes the <code>capacity_mw_share</code> column.</p>
<hr /> Now let&#39;s analyse features which exhibit some missing values. Suppose we want to calculate the age of each plant &#40;rounded to full years&#41;. We face two issues. First, the commissioning_year is not reported for all plants. We need to gauge the representativity of the plants for which it is available with regard to the full dataset. One way to count the missing values is</p>
<pre><code class="language-julia">nMissings = length(findall(x -> ismissing(x), data.commissioning_year))</code></pre><pre><code class="plaintext">17340</code></pre>
<p>This represents about half of our observations</p>
<pre><code class="language-julia">nMissings_share = nMissings/size(data)[1]</code></pre><pre><code class="plaintext">0.515411824153613</code></pre>
<p>Second, the commissioning year is not reported as an integer. Fractions of years are reported too. As a result, the machine type of <code>data.commissioning_year</code>is Float64.</p>
<pre><code class="language-julia">typeof(data.commissioning_year)</code></pre><pre><code class="plaintext">Array{Union{Missing, Float64},1}</code></pre>
<p>Before calculating the average age, let&#39;s drop the missing values.</p>
<pre><code class="language-julia">data_nmiss = dropmissing(data, :commissioning_year);</code></pre>
<p>And round the year to the closest integer. We can do this using the <code>round</code> function and a mapping function on the relevant DataFrame column.</p>
<pre><code class="language-julia">map!(x -> round(x, digits=0), data_nmiss.commissioning_year, data_nmiss.commissioning_year);

# We can now calculate plant age for each plant (worth remembering that the dataset only contains active plants)

current_year = fill!(Array{Float64}(undef, size(data_nmiss)[1]), 2020);
data_nmiss[:, :plant_age] = current_year - data_nmiss[:, :commissioning_year];</code></pre>
<p>Since the commissioning year is missing for about half the plants in the dataset &#40;17340, see description of data above&#41; and that missing values propagate, the plant age will only be available for 33643-17340 plants. Let&#39;s see what the mean and median plant ages are across the plants for which we have the data</p>
<pre><code class="language-julia">mean_age = mean(skipmissing(data_nmiss.plant_age))
median_age = median(skipmissing(data_nmiss.plant_age))</code></pre><pre><code class="plaintext">15.0</code></pre>
<p>And bring this into a frequency plot of the plant age observations</p>
<pre><code class="language-julia">figure(figsize=(8,6))

plt.hist(data_nmiss.plant_age, color="blue", edgecolor="white", bins=100,
      density=true, alpha=0.5)
plt.axvline(mean_age, label = "Mean", color = "red")
plt.axvline(median_age, label = "Median")

plt.legend()

plt.xlim(0,)</code></pre>
<img src="/DataScienceTutorials.jl/assets/data/processing/code/output/D0-processing-g2.svg" alt="the alt here">
<p>We can also calculate and plot average plant age by country and technology Make sure all columns passed, other than the aggregation dimensions, are of type <code>Float</code> or <code>Int</code>, otherwise the function execution will fail.</p>
<pre><code class="language-julia">age = select(data_nmiss, [:country, :primary_fuel, :plant_age])
age_mean = combine(groupby(age, [:country, :primary_fuel]), :plant_age => mean)

coal_means = age_mean[occursin.(ctry_selec, age_mean.country) .& occursin.(r"Coal", age_mean.primary_fuel), :]
gas_means = age_mean[occursin.(ctry_selec, age_mean.country) .& occursin.(r"Gas", age_mean.primary_fuel), :]

width = 0.35  # the width of the bars

fig, (ax1, ax2) = plt.subplots(1,2)

fig.suptitle("Mean plant age by country and technology")

ax1.bar(coal_means.country, coal_means.plant_age_mean, width, label="Coal")
ax2.bar(gas_means.country, gas_means.plant_age_mean, width, label="Gas")

ax1.set_ylabel("Age")

ax1.set_title("Coal")
ax2.set_title("Gas")</code></pre>
<img src="/DataScienceTutorials.jl/assets/data/processing/code/output/D0-processing-g3.svg" alt="the alt here"><div class="page-foot">
  <div class="copyright">
    &copy; Thibaut Lienart, Anthony Blaom and collaborators. Last modified: July 18, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
      </div> <!-- end of id=main -->
  </div> <!-- end of id=layout -->
  <script src="/DataScienceTutorials.jl/libs/pure/ui.min.js"></script>
  
  
      <script src="/DataScienceTutorials.jl/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

  
</body>
</html>
